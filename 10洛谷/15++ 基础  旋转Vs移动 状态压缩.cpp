#include <all.h>
// 现在教学资源这么丰富。只要你敢冲。没有啥知识点是 你拿不下的。加油 上山人。
#include <unordered_map>
#include <bits/stdc++.h>
using namespace std;
// 录入不一定要全录入
// 可以提取成我们要的数据样子。
// 输出也是。不一定要处理完放的好好的输出。
// 可以在一个临时的空间数据。
char c[10][10];
bool vis[160000];
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
// 函数内的函数！！！！！！！！这个有时候也用的到
int x, y, a, b;
bool ok(int l, int r)
{
    return l >= 0 && r >= 0 && l < 10 && r < 10 && c[l][r] != '*';
}

int main()
{
    // 两个方向 一个方向是cnt 到了。另外一个方向是走入死循环。。
    for (int i = 0; i < 10; ++i)
        for (int j = 0; j < 10; ++j)
        {
            cin >> c[i][j];
            if (c[i][j] == 'C')
                a = i, b = j;
            else if (c[i][j] == 'F')
                x = i, y = j;
        }
    int cnt = 0;
    int i = 0, j = 0;
    do
    {
        cnt++;
        int k = x + y * 10 + a * 100 + b * 1000 + i * 10000 + j * 40000;
        if (vis[k])
        {
            cout << 0;
            return 0;
        }
        vis[k] = 1;
        // if就是移动。。
        if (ok(x + dx[i], y + dy[i]))
        {
            x += dx[i], y += dy[i];
        }
        else
            i = (i + 1) % 4;
        // 这就是转头。。
        if (ok(a + dx[j], b + dy[j]))
        {
            a += dx[j], b += dy[j];
        }
        else
            j = (j + 1) % 4;
        if (x == a && y == b)
            break;

    } while (cnt);
    cout << cnt;
    return 0;
}

// 也可以称作 维度压缩
// 也可以称作 维度压缩
// 也可以称作 维度压缩
// 也可以称作 维度压缩
// 64个维度  压缩成1个维度
// 64个维度  压缩成1个维度
// 64个维度  压缩成1个维度
// 他碰到的时候 他是不移动的。。转头算一步！！！！！！！！！！！！
// 他碰到的时候 他是不移动的。。转头算一步！！！！！！！！！！！
// 他碰到的时候 他是不移动的。。转头算一步

// 然后这种移动模式 是非常容易进死胡同的。来回走。

// 我这种设计比他那个好多了。。妙就妙在我可以一直保持i j
// i j 有又一直能取到对应的旋转位置。。
// 而且不旋转的时候的i j 又能够拿到对应的移动方向的坐标。。
// 所以 不论是旋转还是移动 。我都用一个坐标系解决了。。
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
// 这个意味着 上做下右的移动。。
// 然后i j保持不变的时候 又能取到对应位置应有的偏移位置。。。
// 一举两得。。。

// 然后牛逼的就是这个状态压缩了
int k = x + y * 10 + a * 100 + b * 1000 + (i + 1) * 10000 + (j + 1) * 40000;
// 几个状态就增加后面的倍数。。
// 这个状态压缩是这题的核心。
// 然后就是旋转和移动的实现
// 然后就是旋转和移动的实现
// 然后就是旋转和移动的实现
// 保持移动 就是一直取对应的偏移坐标 i 不动。
// 然后旋转要依赖偏移坐标体系的设计。让（i+1）%4；