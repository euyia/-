#include <all.h>
// 现在教学资源这么丰富。只要你敢冲。没有啥知识点是 你拿不下的。加油 上山人。
#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <bits/stdc++.h>
using namespace std;
// int n, a, b, c = 1;
// int main()
// {
//     stack<int> s;
//     cin >> n;
//     while (n--)
//     {
//         int x[a + 1], y[a + 1];
//         cin >> a;
//         for (int i = 1; i <= a; ++i)
//             cin >> x[i];
//         for (int i = 1; i <= a; ++i)
//             cin >> y[i];
//         for (int i = 1; i <= a; ++i)
//         {
//             s.push(x[i]);
//             while (s.size() && s.top() == y[c])
//             {
//                 c++;
//                 s.pop();
//             }
//         }
//         if (s.empty())
//             cout << "Yes" << endl;
//         // 这yes的大小写 也是要注意。也是醉了。
//         else
//             cout << "No" << endl;
//         while (s.size())
//             s.pop();
//     }
//     return 0;
// }

// // stack<int>q;//栈q
// // int p,n;//p组数据，n为序列长度
// // int main()
// // {
// // 	cin>>p;
// // 	while(p--)
// // 	{
// // 		cin>>n;
// // 		int a[n+1],b[n+1],sum=1;//入栈队列a，待检验队列b，计数器sum
// // 		for(int i=1;i<=n;i++)
// // 		cin>>a[i];
// // 		for(int i=1;i<=n;i++)
// // 		cin>>b[i];//平平无奇的输入
// // 		for(int i=1;i<=n;i++)
// // 		{
// // 			q.push(a[i]);//入栈
// // 			while((q.top())==b[sum])//当栈顶元素与b中当前元素相同时出栈
// // 			{
// // 				q.pop(),sum++;//sum++到b下一个元素
// // 				if(q.empty())break;//注意这里，第一次RE就因为当栈空时还用了出栈操作，所以要手动结束循环
// // 			}
// // 		}
// // 		if(q.empty()) cout<<"Yes"<<endl;//如果栈为空说明出栈序列b正确
// // 		else cout<<"No"<<endl;
// // 		while(!q.empty())q.pop();//清空栈
// // 	}
// // 	return 0;//谢幕
// // }
// // 很奇怪的一题。。p4387  不知道什么细节错了。。
// // 我写案例第一个题。是对的。
// // 索命至少有一个是对的才是。但是都是错的。。可能输出的格式问题？？？？
using namespace std;
int main()
{
    //func();
    int x = __cplusplus;
    cout << x << endl;
    return 0;
}