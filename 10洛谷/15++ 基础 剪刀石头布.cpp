#include <all.h>
// 现在教学资源这么丰富。只要你敢冲。没有啥知识点是 你拿不下的。加油 上山人。
#include <unordered_map>
#include <bits/stdc++.h>
using namespace std;
// 录入不一定要全录入
// 可以提取成我们要的数据样子。
// 输出也是。不一定要处理完放的好好的输出。
// 可以在一个临时的空间数据。
int n, m;
int x, y, r, z;
int a[505], b[505];
int c[5][5] = {
    0,
    -1,
    1,
    1,
    -1,
    0,
    0,
    -1,
    1,
    -1,
    0,
    0,
    0,
    -1,
    1,
    0,
    0,
    1,
    0,
    1,
    0,
    0,
    1,
    1,
    0,

};
int main()
{

    // for (int i = 0; i < 5; ++i, cout << '\n')
    //     for (int j = 0; j < 5; ++j)
    //         cout << c[i][j];
    int n, ll, rr;
    cin >> n >> ll >> rr;
    int l = 0, r = 0;

    for (int i = 0; i < ll; ++i)
        cin >> a[i];
    for (int i = 0; i < rr; ++i)
        cin >> b[i];
    int left = 0, right = 0;
    for (int i = 0; i < n; ++i, l++, r++)
    {
        if (l == ll)
            l = 0;
        if (r == rr)
            r = 0;
        int k;
        if (a[l] > b[r])
        {
            k = c[b[r]][a[l]];
            k *= -1;
        }
        else
            k = c[a[l]][b[r]];
        left += (k < 0 ? 0 : k);
        right -= (k > 0 ? 0 : k);
    }
    cout << left << ' ' << right;
    return 0;
}
// 这题记录下来主要好玩把。
// 然后也弄了半个多小时。。
// 弯路。。
// 建这个表 。
// 然后就是下标要统一。。
// 你要么都是0  要么都 1开始
// 一般情况下都可以的。。
// 主要看他给的数据。。
//
10 5 6 0 1 2 3 4 0 3 4 2 1 0
// 这题很明显他给的数据都是从0 开始的下标。所以。我们最好和他保持一致。
// 不然你要对他的数据全部进行偏移 。。就很不划算。。
// 所以。。用什么坐标参考 。
// 1 是习惯 2 是要看题目的。。
// 1 是习惯 2 是要看题目的。。
// 1 是习惯 2 是要看题目的。。
// 核心原则 就是要保持一致
// 核心原则 就是要保持一致
// 核心原则 就是要保持一致
#include <bits/stdc++.h>
    using namespace std;
const int MAXN = 200 + 10;
int n, na, nb, a[MAXN], b[MAXN], cnta, cntb;
int vs[5][5] = {{0, 0, 1, 1, 0}, {1, 0, 0, 1, 0}, {0, 1, 0, 0, 1}, {0, 0, 1, 0, 1}, {1, 1, 0, 0, 0}}; //得分表的处理
int main()
{
    cin >> n >> na >> nb;
    for (int i = 0; i < na; i++)
        cin >> a[i];
    for (int i = 0; i < nb; i++)
        cin >> b[i];
    for (int i = 0; i < n; i++)
    {
        cnta += vs[a[i % na]][b[i % nb]]; //周期循环
        cntb += vs[b[i % nb]][a[i % na]];
    }
    cout << cnta << " " << cntb << endl;
    return 0;
}
// 其实应该像他这样的 把这个表建完整了。。
// 这样子  又省去判断a b大小的问题。。
// 然后 他这里 用取余 来做循环。更加简洁。。
int wa[5][5] = {0, 0, 1, 1, 0,
                1, 0, 0, 1, 0,
                0, 1, 0, 0, 1,
                0, 0, 1, 0, 1,
                1, 1, 0, 0, 0};
// 他这里用空格来维护了。。表的形状。。这样不会改变数据吗 --
//
// 取余实现循环  建完整的表 大大简化了逻辑处理
// 取余实现循环  建完整的表 大大简化了逻辑处理
// 取余实现循环  建完整的表 大大简化了逻辑处理
